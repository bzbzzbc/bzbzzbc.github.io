<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MISC总结-压缩包</title>
    <link href="/2024/06/12/MISC%E6%80%BB%E7%BB%93-%E5%8E%8B%E7%BC%A9%E5%8C%85/"/>
    <url>/2024/06/12/MISC%E6%80%BB%E7%BB%93-%E5%8E%8B%E7%BC%A9%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="压缩包类"><a href="#压缩包类" class="headerlink" title="压缩包类"></a>压缩包类</h1><h2 id="ZIP"><a href="#ZIP" class="headerlink" title="ZIP"></a>ZIP</h2><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>压缩包的开头是50 4B 03 04，即PK头，数据区开头为50 4B 01 02，结束区为50 4B 05 06</p><p><img src="https://img-blog.csdnimg.cn/a8bf8549832a4250b768bcb2c95b6843.png" alt="在这里插入图片描述"></p><p>一个ip文件有三个部分组成：</p><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志 </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs maxima">压缩源文件数据区：<br><span class="hljs-number">50</span> 4B <span class="hljs-number">03</span> <span class="hljs-number">04</span>：这是头文件标记（<span class="hljs-number">0x04034b50</span>） <br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密） 头文件标记后2bytes<br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：扩展记录长度 <br>6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500 <br></code></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs maxima">压缩源文件目录区： <br><br><span class="hljs-number">50</span> 4B <span class="hljs-number">01</span> <span class="hljs-number">02</span>：目录中文件文件头标记(<span class="hljs-number">0x02014b50</span>) <br><br>3F <span class="hljs-number">00</span>：压缩使用的 pkware 版本<br><br><span class="hljs-number">14</span> <span class="hljs-number">00</span>：解压文件所需 pkware 版本 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：全局方式位标记（有无加密，伪加密的关键） 目录文件标记后4bytes<br><span class="hljs-number">08</span> <span class="hljs-number">00</span>：压缩方式 <br>5A 7E：最后修改文件时间 <br>F7 <span class="hljs-number">46</span>：最后修改文件日期 <br><span class="hljs-number">16</span> B5 <span class="hljs-number">80</span> <span class="hljs-number">14</span>：CRC-<span class="hljs-number">32</span>校验（<span class="hljs-number">1480B516</span>） <br><span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：压缩后尺寸（<span class="hljs-number">25</span>） <br><span class="hljs-number">17</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：未压缩尺寸（<span class="hljs-number">23</span>） <br><span class="hljs-number">07</span> <span class="hljs-number">00</span>：文件名长度 <br><span class="hljs-number">24</span> <span class="hljs-number">00</span>：扩展字段长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：文件注释长度 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：磁盘开始号 <br><span class="hljs-number">00</span> <span class="hljs-number">00</span>：内部文件属性 <br><span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：外部文件属性 <br><br><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>：局部头部偏移量<br><br>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001 <br></code></pre></td></tr></table></figure><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">压缩源文件目录结束标志：** <br>50 4B<span class="hljs-number"> 05 </span>06：目录结束标记 <br>00 00：当前磁盘编号 <br>00 00：目录区开始磁盘编号 <br>01 00：本磁盘上纪录总数 <br>01 00：目录区中纪录总数 <br>59<span class="hljs-number"> 00 </span>00 00：目录区尺寸大小 <br><br>3E<span class="hljs-number"> 00 </span>00 00：目录区对第一张磁盘的偏移量<br><br>00 00：ZIP 文件注释长度<br></code></pre></td></tr></table></figure><h3 id="1、爆破"><a href="#1、爆破" class="headerlink" title="1、爆破"></a>1、爆破</h3><ul><li><strong>Ziperello</strong>在不知道密码位数的情况下暴力破解1~6位（超出6位消耗事件更长），但只可以暴破ZIP文件</li><li><strong>ARCHPR</strong>更适用于在<strong>知道密码格式</strong>的情况下的掩码暴破，适用于ZIP和RAR。</li></ul><p>破解类型：</p><ol><li><strong>暴破</strong>：顾名思义，逐个尝试选定集合中可以组成的所有密码，直到遇到正确密码。选择密码的长度、由哪些字符组成，用软件生成的组合方式逐一爆破</li><li><strong>字典</strong>：字典攻击的效率比破稍高，因为字典中存储了常用的密码，因此就避免了暴破时把时间浪费在脸滚键盘类的密码上。通常是多数用户常用的一些密码集合，导入字典文件用字典中的密码进行破解，一般为弱口令、常用密码的字典。</li><li><strong>掩码攻击</strong>：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 <code>??a???</code> 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比暴破高出不少</li></ol><h3 id="2、伪加密"><a href="#2、伪加密" class="headerlink" title="2、伪加密"></a>2、伪加密</h3><h4 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h4><p>在压缩源文件数据区中，全局方式标记位是00 00  504B0304两个bytes之后</p><p>在压缩源文件目录区中，全局方式标记位是01 00（第二位是奇数即可）  504B0102四个bytes之后</p><p><img src="https://img2018.cnblogs.com/blog/1495876/201810/1495876-20181021113558763-679460068.png" alt="img"></p><p><img src="https://img2018.cnblogs.com/blog/1495876/201810/1495876-20181021113605429-1399978288.png" alt="img"></p><blockquote><p><strong>无加密</strong></p><ul><li>压缩源文件数据区的全局加密通常为<code>00 00</code> (<code>50 4B 03 04</code>两个字节之后）；</li><li>压缩源文件目录区的全局方式位标记通常为<code>00 00</code> (<code>50 4B 01 02</code>四个字节之后）。</li></ul><p><strong>伪加密</strong>：</p><ul><li>压缩源文件数据区的全局加密为<code>00 00</code>；</li><li>压缩源文件目录区的全局方式位标记为<code>09 00</code>。（不一定是9，也可能被篡改成其他奇数）</li></ul><p><strong>真加密</strong>：</p><ul><li>压缩源文件数据区的全局加密通常为<code>09 00</code>；</li><li>压缩源文件目录区的全局方式位标记通常为<code>09 00</code>。</li></ul></blockquote><p>全局方式位标记的四个数字中只有第二个数字对其有影响，其它的不管为何值，都不影响它的加密属性！ </p><p>第二个数字为奇数时 –&gt;加密 </p><p>第二个数字为偶数时 –&gt;未加密</p><h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><h5 id="一、ZipCenOp-jar"><a href="#一、ZipCenOp-jar" class="headerlink" title="一、ZipCenOp.jar"></a>一、ZipCenOp.jar</h5><p>利用ZipCenOp.jar一把梭</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>-<span class="hljs-keyword">jar </span>ZipCenOp.<span class="hljs-keyword">jar </span>r xxx.zip<br></code></pre></td></tr></table></figure><p>需要注意的是使用的时候要把要解压的文件放到和zipcenop一个文件夹，然后再使用命令就行</p><p><img src="https://gitee.com/tznzbc/tan-zhennings-small-warehouse/raw/master/img/202304142055226.png" alt="image-20230321201352387"></p><h5 id="二、Winrar修复"><a href="#二、Winrar修复" class="headerlink" title="二、Winrar修复"></a>二、Winrar修复</h5><p>用winrar打开，选择工具栏的 repair 即可修复压缩包</p><h5 id="三、手动修改"><a href="#三、手动修改" class="headerlink" title="三、手动修改"></a>三、手动修改</h5><p>放进010或者winhex，找到伪加密的位置，找对位置将 01 或 09 修改为 00 即可</p><h4 id="RAR伪加密"><a href="#RAR伪加密" class="headerlink" title="RAR伪加密"></a>RAR伪加密</h4><p>找到第24个字节，该字节尾数为4表示加密，0表示无加密，将尾数改为0即可解开伪加密。</p><h3 id="3、明文攻击"><a href="#3、明文攻击" class="headerlink" title="3、明文攻击"></a>3、明文攻击</h3><p>明文攻击是一种较为高效的攻击手段，大致原理是当不知道一个zip的密码，但是有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。</p><ul><li>找到压缩包内其中一个<strong>已知的文件</strong>（<strong>文件大小要大于12Byte</strong>），用相同的压缩软件<strong>压缩算法</strong>去压缩无密码压缩包，得到明文。</li><li>通过比较两个压缩包相同位置不同的12个字节，就可以还原出3个key，绕过密码提取出所有的文件。</li><li>注意明文攻击需要<strong>CRC32值相同</strong>才行。</li></ul><p>特征：</p><ul><li><p>已知加密压缩包中的一个文件</p><p>确定是否是相同文件就是比较CRC值</p><p>初步判断文件的名字、大小</p><p>这个文件一定要完全一致。比如有一个文件的最后有一小段提示文字，就得删除</p></li><li><p>在进行明文攻击的时候，<strong>确保压缩方式、加密算法要相同</strong></p><p>比如可能提示你存储，快速啥的，这就要在压缩已知文件时的压缩方式选存储等等</p><p> 还有就是算法(这里可以多种压缩软件都试试，比如winrar、7-z、好压等</p><p><strong>这里主要就是压缩的时候要点开高级设置，一项一项和加密文件夹下的相同文件的压缩方式、加密算法要完全一致</strong></p><p>不能直接快捷压缩</p></li></ul><p>之后就是选择好加密文件、攻击类型选择明文、解密文件</p><p>需要注意的是，明文攻击并不需要太多时间，最多也就5,6分钟（师傅们的总结），一旦超过这个时间或感觉可以了点停止即可。</p><p>如果出现秘钥成功恢复就无需再等，直接停止保存文件即无密码的文件。</p><p>如果出现以下错误，那么一般就是你使用的压缩软件或是压缩算法和待破解的压缩包所使用的软件不同，可以用WinRAR，7z，2345好压等都试一下</p><blockquote><p> No matching files in selected archives.If you’d like to run plaintext attack using only part of the file, please modify the archives so <em><strong>each of them will contain one file only.</strong></em></p><p> 在选定的档案中没有匹配的文件。如果您想要仅使用文件的一部分执行明文攻击,请修改档案,使每个档案中只包含一个文件。</p></blockquote><h4 id="ARCHPR"><a href="#ARCHPR" class="headerlink" title="ARCHPR"></a>ARCHPR</h4><p>明文攻击是一种较为高效的攻击手段，大致原理是当不知道一个zip的密码，但是有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。</p><p><strong>1. 出现不能打开ZIP&#x2F;RAR&#x2F;ACE&#x2F;ARJ档案文件的报错</strong></p><img src="https://img-blog.csdnimg.cn/20210520173407833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUyOTc0NzE5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><p><strong>2.遇到的明文攻击的两种类型</strong></p><p>明文攻击的特征：</p><ul><li><p>已知加密压缩包中的一个文件</p><p>确定是否是相同文件就是比较CRC值</p><p>初步判断文件的名字、大小</p><p>这个文件一定要完全一致。比如有一个文件的最后有一小段提示文字，就得删除</p></li><li><p>在进行明文攻击的时候，<strong>确保压缩方式、加密算法要相同</strong></p><p>比如可能提示你存储，快速啥的，这就要在压缩已知文件时的压缩方式选存储等等</p><p> 还有就是算法(这里可以多种压缩软件都试试，比如winrar、7-z、好压等</p><p><strong>这里主要就是压缩的时候要点开高级设置，一项一项和加密文件夹下的相同文件的压缩方式、加密算法要完全一致</strong></p><p>不能直接快捷压缩</p></li></ul><p>之后就是选择好加密文件、攻击类型选择明文、解密文件</p><p><strong>需要注意的是，明文攻击并不需要你太多时间，最多也就5,6分钟（师傅们的总结），一旦超过这个时间或感觉可以了点停止即可。</strong></p><p><strong>如果出现秘钥成功恢复就无需再等，直接停止保存文件即无密码的文件。</strong></p><p>- </p><h4 id="例题1-ACTF新生赛2020-明文攻击"><a href="#例题1-ACTF新生赛2020-明文攻击" class="headerlink" title="例题1[ACTF新生赛2020]明文攻击"></a>例题1[ACTF新生赛2020]明文攻击</h4><p>得到一个包和一张图片</p><p>包里放着flag</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417144452278.png" alt="image-20230417144452278"></p><p>解密需要密码，不是伪加密，winrar无法修复，爆破也得不到，这就是明文攻击</p><p>将图片放进010里面，发现在最后出现了，03 04，05 06，但是没有50 4B</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417144645928.png" alt="image-20230417144645928"></p><p>添加上50 4B打开</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417145044699.png" alt="image-20230417145044699"></p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417145850398.png" alt="image-20230417145850398"></p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417145129059.png" alt="image-20230417145129059"></p><p><code>然后进行明文攻击，因为压缩包的大小不同，可以用winrar自动进行修复 (因为flag.txt的crc32相同，但是压缩后的大小都不同！而且res.zip包压缩后大小比较大)</code></p><p><img src="https://img-blog.csdnimg.cn/fca0a15c522c44aabd9363418a5a6108.png" alt="img"> </p><p><img src="https://img-blog.csdnimg.cn/819523b09d5d435493ae21b7470c3330.png" alt="img"> </p><p> 对比flag.txt的CRC32，发现是一样的，用ARCHPR进行明文攻击</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417145922679.png" alt="image-20230417145922679"></p><h4 id="例题2这就是一个坑"><a href="#例题2这就是一个坑" class="headerlink" title="例题2这就是一个坑"></a>例题2这就是一个坑</h4><p>打开得到一个包和txt</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417150331055.png" alt="image-20230417150331055"></p><p>说明肯定不是爆破密码</p><p>对比两个压缩包里的tips.txt文件，他们的CRC相同，是同一个文件</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417181642602.png" alt="image-20230417181642602"></p><p><strong>已知未加密的 tips 和 flag.zip 里被加密后的 tips，又知是zip加密，故可用AZPR进行明文攻击</strong></p><p><em><strong>*明文攻击使用条件是我们有一个加密压缩包中的一个文件*</strong></em></p><p>如果出现以下错误，那么一般就是你使用的压缩软件或是压缩算法和待破解的压缩包所使用的软件不同，可以用WinRAR，7z，2345好压等都试一下</p><blockquote><p> No matching files in selected archives.If you’d like to run plaintext attack using only part of the file, please modify the archives so <em><strong>each of them will contain one file only.</strong></em></p><p> 在选定的档案中没有匹配的文件。如果您想要仅使用文件的一部分执行明文攻击,请修改档案,使每个档案中只包含一个文件。</p></blockquote><p>&#x3D;&#x3D;这里需要注意的是压缩的时候一定要选好压缩方式和加密算法，和需要解密的文件夹下的相同文件一定要一致&#x3D;&#x3D;</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417183359281.png" alt="image-20230417183359281"></p><p>要不就会报错，和上面的错误一致</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417184304923.png" alt="image-20230417184304923"></p><p>然后打开flag.txt即可</p><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230417184535403.png" alt="image-20230417184535403"></p><p>还有一点就是这里的密码建议直接在ARCHPR中提示复制，因为就像这个会出现后面有很多个空格，放在txt里容易被忽略</p><h4 id="明文攻击快速判断压缩工具"><a href="#明文攻击快速判断压缩工具" class="headerlink" title="明文攻击快速判断压缩工具"></a><strong>明文攻击快速判断压缩工具</strong></h4><table><thead><tr><th>压缩工具</th><th>VersionMadeBy(压缩所用版本)</th></tr></thead><tbody><tr><td>Bandizip 7.06</td><td>20</td></tr><tr><td>Windows自带</td><td>20</td></tr><tr><td>WinRAR 4.20</td><td>31</td></tr><tr><td>WinRAR 5.70</td><td>32</td></tr><tr><td>7-Zip</td><td>63</td></tr></tbody></table><p><img src="C:\Users\谭振宁\AppData\Roaming\Typora\typora-user-images\image-20230424130614982.png" alt="image-20230424130614982"></p><h3 id="4、CRC32碰撞"><a href="#4、CRC32碰撞" class="headerlink" title="4、CRC32碰撞"></a>4、CRC32碰撞</h3><p>Misc中的有一类题目是<strong>我们需要知道加密后的压缩文件中的内容，但是压缩文件的密码我们不知道，直接暴破密码也不是很现实，但是当文件的大小比较小，或者字符数量较少</strong>，这个时候就可以构造一个和源文件等长的字符串，然后再对其进行CRC校验，比较校验码是否相同以此来暴破出压缩文件内部文件的内容。</p><p>CRC“ 冗余校验码”，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。</p><p>在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这</p><p>个原理我们可以直接爆破出加密文件的内容</p><p>若是知道一段数据的长度和CRC32值，便可穷举数据，与其CRC32对照，以此达到暴力猜解的目的。但只适用于较小文本文件。</p><p>CRC攻击：</p><ul><li><strong>文件内内容很少 (一般比赛中大多为 4 字节左右)</strong><br><strong>加密的密码很长</strong></li><li>我们不去爆破压缩包的密码，而是直接去爆破源文件的内容 (一般都是可见的字符串)，从而获取想要的信息。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> zlib<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> itertools<br><span class="hljs-keyword">import</span> struct<br><br><span class="hljs-comment"># 爆破所有可能的crc，存起来</span><br>alph = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=&#x27;</span><br>crcdict = &#123;&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;computing all possible CRCs...&quot;</span>)<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> itertools.product(<span class="hljs-built_in">list</span>(alph), repeat=<span class="hljs-number">3</span>):<br>    st = <span class="hljs-string">&#x27;&#x27;</span>.join(x)<br>    testcrc = zlib.crc32(st.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>))<br>    crcdict[testcrc] = st<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Done!&quot;</span>)<br><span class="hljs-built_in">print</span>(crcdict)<br><br><span class="hljs-comment"># 判断crc是否在集合中</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.zip&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>)<br>data = f.read()<br>f.close()<br>crc = <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-string">&#x27;%s&#x27;</span> %<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> data[<span class="hljs-number">14</span>:<span class="hljs-number">18</span>])<br><span class="hljs-keyword">if</span> crc <span class="hljs-keyword">in</span> crcdict:<br>    <span class="hljs-built_in">print</span>(crcdict[crc])<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FAILED!&quot;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> binascii<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CrackCrc</span>(<span class="hljs-params">crc</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dic:<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> dic:<br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-keyword">for</span> h <span class="hljs-keyword">in</span> dic:<br>                    s = i + j + k + h<br>                    <span class="hljs-keyword">if</span> crc == (binascii.crc32(s.encode())):<br>                        f.write(s)<br>                        <span class="hljs-keyword">return</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">CrackZip</span>():<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">68</span>):<br>            file = <span class="hljs-string">&#x27;./3/out&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.zip&#x27;</span><br>            crc = zipfile.ZipFile(file,<span class="hljs-string">&#x27;r&#x27;</span>).getinfo(<span class="hljs-string">&#x27;data.txt&#x27;</span>).CRC<br>            CrackCrc(crc)<br><br>dic = string.ascii_letters + string.digits + <span class="hljs-string">&#x27;+/=&#x27;</span><br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./3/out.txt&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>)<br>CrackZip()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CRC32碰撞完成&quot;</span>)<br>f.close()<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import binascii<br>import string<br> <br><span class="hljs-attribute">dic</span>=string.printable #打印出字符表<br><span class="hljs-attribute">crc1</span>=0x7DE0AB32<br><span class="hljs-attribute">crc2</span>=0xB1441D53<br><span class="hljs-attribute">crc3</span>=0x49BD11F5<br><span class="hljs-attribute">crc4</span>=0xB42F1DFA<br><span class="hljs-attribute">crc5</span>=0x8163F43E<br><span class="hljs-attribute">crc6</span>=0x1FC8FEE5<br> <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dic:<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> dic:<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> dic:<br>            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> dic:<br>                <span class="hljs-attribute">s</span>=i+j+n+m<br>                <span class="hljs-keyword">if</span>(<span class="hljs-attribute">crc1</span>==(binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text1</span>=s<br>                <span class="hljs-keyword">if</span> (crc2 == (binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text2</span>=s<br>                <span class="hljs-keyword">if</span> (crc3 == (binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text3</span>=s<br>                <span class="hljs-keyword">if</span> (crc4 == (binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text4</span>=s<br>                <span class="hljs-keyword">if</span> (crc5 == (binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text5</span>=s<br>                <span class="hljs-keyword">if</span> (crc6 == (binascii.crc32(s) &amp; 0xffffffff)):<br>                    <span class="hljs-attribute">text6</span>=s<br><span class="hljs-built_in">print</span> text1+text2+text3+text4+text5+text6<br><br><br></code></pre></td></tr></table></figure><p>可以利用脚本来破解</p><p>也可以利用工具：<a href="https://github.com/theonlypwner/crc32">https://github.com/theonlypwner/crc32</a></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">`<span class="hljs-keyword">python</span> crc32.<span class="hljs-keyword">py</span> <span class="hljs-built_in">reverse</span> 你的crc32密文`（密文需要加上<span class="hljs-number">0</span><span class="hljs-keyword">x</span>变成<span class="hljs-number">16</span>进制）<br></code></pre></td></tr></table></figure><h3 id="5、压缩包注释"><a href="#5、压缩包注释" class="headerlink" title="5、压缩包注释"></a>5、压缩包注释</h3><p>注意留心压缩包的注释</p><h2 id="RAR"><a href="#RAR" class="headerlink" title="RAR"></a>RAR</h2><p>RAR文件格式主要有RAR-4和RAR-5两种，在使用WinRAR创建RAR文件时可以选择采用什么版本会生成对应格式的RAR文件</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>RAR文件由可变长度的块组成。这些块的顺序可以变化，但是第一个块必须是标记块，然后是压缩文件头块</p><p>通用字段结构如下表：</p><table><thead><tr><th align="left">名称</th><th align="left">大小</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">HEAD_CRC</td><td align="left">2</td><td align="left">整个块或者对块某个部分的CRC</td></tr><tr><td align="left">HEAD_TYPE</td><td align="left">1</td><td align="left">当前块的类型，不同的块对应不同的HEAD_TYPE，如下 <code>标记块</code>：0x72 <code>压缩文件头</code>：0x73 <code>文件头</code>：0x74 <code>注释头</code>：0x75 <code>旧风格的用户身份信息</code>：0x76 <code>子块</code>：0x77 <code>恢复纪录</code>：0x78 <code>用户身份信息</code>：0x79 <code>子块</code>：0x7a <code>结尾块</code>：0x7b</td></tr><tr><td align="left">HEAD_FLAGS</td><td align="left">2</td><td align="left">快标志</td></tr><tr><td align="left">HEAD_SIZE</td><td align="left">2</td><td align="left">当前块的大小</td></tr><tr><td align="left">ADD_SIZE</td><td align="left">4</td><td align="left">添加块的大小（可选，只有在块标记的第一位被置1的话时存在）</td></tr></tbody></table><p>现在的RAR-4.x 文件主要由标记块，压缩文件头块，文件头块，结尾块组成，其它块常出现在旧版本的rar文件中</p><h4 id="（1）标记块（签名）"><a href="#（1）标记块（签名）" class="headerlink" title="（1）标记块（签名）"></a>（1）标记块（签名）</h4><p>标记块也称为<code>Magic number</code>，大小固定是7 个字节，且是一个固定的字节序列<code>52 61 72 21 1A 07 00</code>。</p><blockquote><p>RAR 5.0的标记块和RAR4.x的不一样，RAR 5.0签名由8个字节组成</p><p>highlighter- apache</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000h</span>: <span class="hljs-number">52</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">21</span> <span class="hljs-number">1</span>A <span class="hljs-number">07</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span>  Rar!....<br></code></pre></td></tr></table></figure></blockquote><table><thead><tr><th align="left">字段</th><th align="left">值</th><th align="left">长度（B）</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HEAD_CRC</td><td align="left">0x6152</td><td align="left">2</td><td align="left">固定</td></tr><tr><td align="left">HEAD_TYPE</td><td align="left">0x72</td><td align="left">1</td><td align="left">固定</td></tr><tr><td align="left">HEAD_FLAGS</td><td align="left">0x1A21</td><td align="left">2</td><td align="left">固定</td></tr><tr><td align="left">HEAD_SIZE</td><td align="left">0x0007</td><td align="left">2</td><td align="left">块大小 &#x3D; 0x0007,即7个字节</td></tr></tbody></table><h4 id="（2）压缩文件头（MAIN-HEAD）"><a href="#（2）压缩文件头（MAIN-HEAD）" class="headerlink" title="（2）压缩文件头（MAIN_HEAD）"></a>（2）压缩文件头（MAIN_HEAD）</h4><table><thead><tr><th align="left">字段名称</th><th align="center">长度(B)</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HEAD_CRC</td><td align="center">2</td><td align="left">HEAD_TYPE到RESERVED2的CRC</td></tr><tr><td align="left">HEAD_TYPE</td><td align="center">1</td><td align="left">0x73</td></tr><tr><td align="left">HEAD_FLAGS</td><td align="center">2</td><td align="left">位标记： <code>0x0001</code> - MHD_VOLUME: 卷属性(压缩文件卷) <code>0x0002</code> - MHD_COMMENT: 压缩文件注释存在，RAR 3.x使用单独的注释块，不设置这个标记。 <code>0x0004</code> - MHD_LOCK: 压缩文件锁定属性 <code>0x0008</code> - MHD_SOLID: 固实属性(固实压缩文件) <code>0x0010</code> - MHD_NEWNUMBERING: 新的卷命名法则(‘volname.partN.rar’) <code>0x0020</code> - MHD_AV: 用户身份信息存在，RAR 3.x使用单独的用户身份信息块，不设置这个标记。 <code>0x0040</code> - MHD_PROTECT: 恢复记录存在 <code>0x0080</code> - HD_PASSWORD: 块头被加密 <code>0x0100</code> - MHD_FIRSTVOLUME: 第一卷(只有RAR3.0及以后版本设置) <code>0x0200</code> - MHD_ENCRYPTVER: HEAD_FLAGS中的其他位保留用于内部使用。</td></tr><tr><td align="left">HEAD_SIZE</td><td align="center">2</td><td align="left">压缩文件头总大小（包括压缩文件注释）</td></tr><tr><td align="left">RESERVED1</td><td align="center">2</td><td align="left">保留</td></tr><tr><td align="left">RESERVED2</td><td align="center">4</td><td align="left">保留</td></tr></tbody></table><blockquote><p>对于<strong>压缩文件头</strong>里的<strong>位标记</strong>，如果它的第9位（从左到右）被置1，块头被加密，也就是通常所说的加密文件名，打开这样加密的RAR文件时，需要先输入密码才能看到压缩包内的文件列表。</p></blockquote><h4 id="（3）文件头（FILE-HEAD）"><a href="#（3）文件头（FILE-HEAD）" class="headerlink" title="（3）文件头（FILE_HEAD）"></a>（3）文件头（FILE_HEAD）</h4><table><thead><tr><th align="left">字段名称</th><th align="center">长度(B)</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HEAD_CRC</td><td align="center">2</td><td align="left">从HEAD_TYPE到FILEATTR的CRC</td></tr><tr><td align="left">HEAD_TYPE</td><td align="center">1</td><td align="left">0x74</td></tr><tr><td align="left">HEAD_FLAGS</td><td align="center">2</td><td align="left">位标记: <code>0x0001</code> - LHD_SPLIT_BEFORE: 文件从上一卷继续 <code>0x0002</code> - LHD_SPLIT_AFTER: 文件从后一卷继续 <code>0x0004</code> - LHD_PASSWORD: 文件使用密码加密 <code>0x0008</code> - LHD_COMMENT: 文件注释存在，RAR 3.x使用独立的注释块，不设置这个标记。 <code>0x0010</code> - LHD_SOLID: 前一文件信息被使用(固实标记) (对于RAR 2.0 和以后版本)    7 6 5 位(对于RAR 2.0和以后版本)    0 0 0 - 字典大小 64KB   0 0 1 - 字典大小 128KB   0 1 0 - 字典大小 256KB    0 1 1 - 字典大小 512KB   1 0 0 - 字典大小 1024KB    1 0 1 - 字典大小 2048KB   1 1 0 - 字典大小 4096KB   1 1 1 - 文件作为字典 <code>0x0100</code> - LHD_LARGE: HIGH_PACK_SIZE和HIGH_UNP_SIZE结构存在。这些结构仅用在非常大(大于2GB)的文档，对于小文件这些结构不存在。 <code>0x0200</code> - LHD_UNICODE: FILE_NAME是用0隔开的包含普通的和Unicode编码的文件名。所以NAME_SIZE字段的值等于普通文件名的长度加Unicode编码文件名的长度再加1。如果此标记存在，但是FILE_NAME不包含0字节，它意味文件名使用UTF-8编码。 <code>0x0400</code> - LHD_SALT: 文件头在文件名后包含附加的8byte，它对于增加加密的安全性是必需的。(所谓的’Salt’)。 <code>0x0800</code> - LHD_VERSION: 版本标记。它是旧文件版本，版本号作为’;n’附加到文件名后。 <code>0x1000</code> - LHD_EXTTIME: 扩展时间区域存在。 <code>0x2000</code> - LHD_EXTFLAGS <code>0x8000</code> - 此位总被设置，所以完整的块的大小是HEAD_SIZE + PACK_SIZE(如果<code>0x100</code>位被设置，再加上HIGH_PACK_SIZE)</td></tr><tr><td align="left">HEAD_SIZE</td><td align="center">2</td><td align="left">文件头的全部大小(包含文件名和注释)</td></tr><tr><td align="left">PACK_SIZE</td><td align="center">4</td><td align="left">已压缩文件大小</td></tr><tr><td align="left">UNP_SIZE</td><td align="center">4</td><td align="left">未压缩文件大小</td></tr><tr><td align="left">HOST_OS</td><td align="center">1</td><td align="left">保存压缩文件使用的操作系统 <code>0x00</code> - MS DOS <code>0x01</code> - OS&#x2F;2 <code>0x02</code> - Win32 <code>0x03</code> - Unix <code>0x04</code> - Mac OS <code>0x05</code> - BeOS</td></tr><tr><td align="left">FILE_CRC</td><td align="center">4</td><td align="left">文件CRC</td></tr><tr><td align="left">FTIME</td><td align="center">4</td><td align="left">MS DOS标准格式的日期和时间</td></tr><tr><td align="left">UNP_VER</td><td align="center">1</td><td align="left">解压文件所需要最低RAR版本，版本编码方法：10 * 主版本 + 副版本。</td></tr><tr><td align="left">METHOD</td><td align="center">1</td><td align="left">压缩方式： <code>0x30</code> - 存储 <code>0x31</code> - 最快压缩 <code>0x32</code> - 较快压缩 <code>0x33</code> - 标准压缩 <code>0x34</code> - 较好压缩 <code>0x35</code> - 最好压缩</td></tr><tr><td align="left">NAME_SIZE</td><td align="center">2</td><td align="left">文件名大小</td></tr><tr><td align="left">ATTR</td><td align="center">4</td><td align="left">文件属性</td></tr><tr><td align="left">HIGH_PACK_SIZE</td><td align="center">4</td><td align="left">可选值，<code>已压缩文件大小</code>64位值的高4字节。只HEAD_FLAGS中的<code>0x100</code>位被设置才存在。</td></tr><tr><td align="left">HIGH_UNP_SIZE</td><td align="center">4</td><td align="left">可选值，<code>未压缩文件大小</code>64位值的高4字节。只有HEAD_FLAGS中的<code>0x100</code>位被设置才存在。</td></tr><tr><td align="left">FILE_NAME</td><td align="center">NAME_SIZE</td><td align="left">文件名 - NAME_SIZE字节大小字符串</td></tr><tr><td align="left">SALT</td><td align="center">8</td><td align="left">可选值，如果(HEAD_FLAGS &amp; 0x400)!&#x3D; 0，则存在</td></tr><tr><td align="left">EXT_TIME</td><td align="center">可变大小</td><td align="left">可选值，扩展时间区域，如果(HEAD_FLAGS &amp; 0x1000)!&#x3D; 0，则存在</td></tr></tbody></table><h4 id="（4）结尾块（ENDARC-HEAD-）"><a href="#（4）结尾块（ENDARC-HEAD-）" class="headerlink" title="（4）结尾块（ENDARC_HEAD ）"></a>（4）结尾块（ENDARC_HEAD ）</h4><p>与标记块类似的是，结尾块也是一个固定字节串的块，依次是<code>C4 3D 7B 00 40 07 00</code>。</p><table><thead><tr><th align="left">字段名称</th><th align="center">长度(B)</th><th align="left">值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">HEAD_CRC</td><td align="center">2</td><td align="left">0x3DC4</td><td align="left">从HEAD_TYPE 到HEAD_SIZE 的CRC校验值</td></tr><tr><td align="left">HEAD_TYPE</td><td align="center">1</td><td align="left">0x7b</td><td align="left">0x7B</td></tr><tr><td align="left">HEAD_FLAGS</td><td align="center">2</td><td align="left">0x4000</td><td align="left">位标记</td></tr><tr><td align="left">HEAD_SIZE</td><td align="center">2</td><td align="left">0x0007</td><td align="left">结尾块大小</td></tr></tbody></table><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><h4 id="（1）密码破解"><a href="#（1）密码破解" class="headerlink" title="（1）密码破解"></a>（1）密码破解</h4><p>ARCHPR工具支持多种破解RAR文件密码的方式。</p><blockquote><h5 id="——常见问题"><a href="#——常见问题" class="headerlink" title="——常见问题"></a>——常见问题</h5><p><strong>Q：RAR文件导入ARCHPR后提示非档案文件，但确实是RAR文件没错</strong></p><p>A：ARCHPR只能破解RAR-4.x的，RAR-5.0的会显示不是档案文件</p></blockquote><h4 id="（2）RAR伪加密"><a href="#（2）RAR伪加密" class="headerlink" title="（2）RAR伪加密"></a>（2）RAR伪加密</h4><p>RAR 文件的伪加密在<strong>文件头</strong>中的<strong>位标记</strong>字段上，用 010 Editor 可以很清楚的看见这一位，修改这一位可以造成伪加密。</p><p><a href="https://em0ser1t-image.oss-cn-hangzhou.aliyuncs.com/img/image-20230418210931421.png"><img src="https://em0ser1t-image.oss-cn-hangzhou.aliyuncs.com/img/image-20230418210931421.png" alt="img"></a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
